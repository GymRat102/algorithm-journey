## 030 - 异或操作

### 交换两个数

### 不用判断和比较，返回两个数的最大值

### 数组中缺失的数字

### 找到数组中出现奇数次的那个数

### 数组中两个数出现奇数次，找到他俩

Brain Kerninghan 算法计算出一个数「最右侧的那个1」的那个状态
- 一个数取反 + 1 是它的相反数

然后把数字按照「这一位是不是1」，将数字分为两组

### 数组中只有1种数出现次数少于m次，其他数都出现了m次，找出前者

取模就是 k 进制异或

## 066 -【必备】从递归入手一维动态规划

算法世界大致分为怎么算和怎么试两种题目，动态规划就是后者。
能用动态规划解的题通常和递归有关。

### 斐波纳契数列 

1. 按照公式从上往下递归展开
有重复计算的子过程，二叉树展开的过程是 O(n^2)

2. 用缓存表来节省重复的子过程展开
算过的结果就放到缓存表里，下次如果需要就直接取结果，不展开。
时间复杂度近似于二叉树的高度 O(n) 复杂度（带毛刺的左边界，毛刺就是取值快速返回的过程）。
写法上是一个挂着缓存表的递归。
注意缓存表的大小是 n + 1

3. 自底向上递推
优化过的递归，反过来也可以从下往上递推来计算。
同样申请缓存表，不过目标是 n，就从 0 和 1 算上去。

4. 继续优化，优化变量
分析好递推顺序后，就不用申请缓存表，循环利用中间变量就可以递推到结果。

5.（以后）最好的解法是矩阵快速幂，能达到 O(log n)