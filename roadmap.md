## 030 - 异或操作

### 交换两个数

### 不用判断和比较，返回两个数的最大值

### 数组中缺失的数字

### 找到数组中出现奇数次的那个数

### 数组中两个数出现奇数次，找到他俩

Brain Kerninghan 算法计算出一个数「最右侧的那个1」的那个状态
- 一个数取反 + 1 是它的相反数

然后把数字按照「这一位是不是1」，将数字分为两组

### 数组中只有1种数出现次数少于m次，其他数都出现了m次，找出前者

取模就是 k 进制异或

## 066 -【必备】从递归入手一维动态规划

算法世界大致分为怎么算和怎么试两种题目，动态规划就是后者。
能用动态规划解的题通常和递归有关。

### 斐波纳契数列 

1. 按照公式从上往下递归展开
有重复计算的子过程，二叉树展开的过程是 O(n^2)

2. 用缓存表来节省重复的子过程展开
算过的结果就放到缓存表里，下次如果需要就直接取结果，不展开。
时间复杂度近似于二叉树的高度 O(n) 复杂度（带毛刺的左边界，毛刺就是取值快速返回的过程）。
写法上是一个挂着缓存表的递归。
注意缓存表的大小是 n + 1

3. 自底向上递推
优化过的递归，反过来也可以从下往上递推来计算。
同样申请缓存表，不过目标是 n，就从 0 和 1 算上去。

4. 继续优化，优化变量
分析好递推顺序后，就不用申请缓存表，循环利用中间变量就可以递推到结果。

5.（以后）最好的解法是矩阵快速幂，能达到 O(log n)

### 旅行最低票价

1. 递归暴力解法
三种方案，每次挑一个方案，然后递归计算选择这个方案之后剩下的最低票价，最后取 min。
重点在于「选择方案之后剩下的方案」，需要一个枚举过程来确定递归参数。
时间复杂度是 3^n 展开。

2. 记忆化搜索
需要的缓存结构大小由可变参数的范围来决定。
确定重复计算的存在：用不同的方案都可以达到同一个剩余天数数组。
记忆化搜索套路：base case -> 缓存搜索 -> 计算 -> 存入缓存
时间复杂度 n，因为只有遍历一遍 days 数组的过程，每次的枚举过程是一个常数时间。

3. 自底向上的标准动态规划解法
从简单的状态如何算出复杂的状态
动态规划的 dp 数组就是用来替代递归的返回：以前是进入新的递归，现在是直接从 dp 里取结果

### 数字解码字母

1. 递归暴力解
每一个位置有三种情况：
- 是 '0' => 无解
- 不是 '0' 就肯定能选定 1 个数，然后加上剩下的
- 判断这一位+下一位是否 <= 26，看能不能再有一种组合

base case，如果位置来到了越界，那就代表收集到一种情况

2. 记忆化搜索
变化的范围是 s 字符数组的长度，在递归的地方带着 dp 数组去递归
O(n)：数组的长度是 n，每次枚举是有限分支

3. 自底向上动态规划
越界位置就是 base case
看位置依赖，i 依赖 i+1 和 i+2
从简单的格子推到复杂的格子，从右向左
以前是递归的地方，现在改为从 dp 里面取值
最后返回 dp[最复杂的格子] 